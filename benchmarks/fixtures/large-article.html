<article class="wiki-article">
  <header>
    <h1>Rust (programming language)</h1>
    <p class="subtitle">A systems programming language focused on safety, speed, and concurrency</p>
  </header>

  <nav class="toc">
    <h2>Contents</h2>
    <ul>
      <li><a href="#history">1 History</a></li>
      <li><a href="#syntax">2 Syntax and semantics</a>
        <ul>
          <li><a href="#hello-world">2.1 Hello World</a></li>
          <li><a href="#variables">2.2 Variables and mutability</a></li>
          <li><a href="#ownership">2.3 Ownership</a></li>
          <li><a href="#references">2.4 References and borrowing</a></li>
          <li><a href="#lifetimes">2.5 Lifetimes</a></li>
        </ul>
      </li>
      <li><a href="#memory-safety">3 Memory safety</a></li>
      <li><a href="#memory-management">4 Memory management</a></li>
      <li><a href="#types">5 Types and polymorphism</a></li>
      <li><a href="#concurrency">6 Concurrency</a></li>
      <li><a href="#ecosystem">7 Ecosystem</a></li>
      <li><a href="#adoption">8 Adoption</a></li>
      <li><a href="#references-section">9 References</a></li>
    </ul>
  </nav>

  <section id="introduction">
    <p>
      <strong>Rust</strong> is a <a href="/wiki/Multi-paradigm_programming_language">multi-paradigm</a>,
      <a href="/wiki/General-purpose_programming_language">general-purpose programming language</a> that emphasizes
      <a href="/wiki/Type_safety">type safety</a>, <a href="/wiki/Memory_safety">memory safety</a>, and
      <a href="/wiki/Concurrency_(computer_science)">concurrency</a>. It enforces memory safety without a
      <a href="/wiki/Garbage_collection_(computer_science)">garbage collector</a>. Rust was originally designed by
      Graydon Hoare at <a href="/wiki/Mozilla_Research">Mozilla Research</a>, with contributions from
      Dave Herman, <a href="/wiki/Brendan_Eich">Brendan Eich</a>, and others.
    </p>

    <p>
      Rust has been called a <em>systems programming language</em> and in addition to high-level features such as
      <a href="/wiki/Functional_programming">functional programming</a> it also offers mechanisms for
      <a href="/wiki/Low-level_programming_language">low-level</a> <a href="/wiki/Memory_management">memory management</a>.
    </p>

    <table class="infobox">
      <tbody>
        <tr>
          <th colspan="2">Rust</th>
        </tr>
        <tr>
          <td colspan="2"><img src="/wiki/Rust_logo.svg" alt="Rust Logo" width="120" /></td>
        </tr>
        <tr>
          <th>Paradigm</th>
          <td>Multi-paradigm: concurrent, functional, generic, imperative, structured</td>
        </tr>
        <tr>
          <th>Designed by</th>
          <td>Graydon Hoare</td>
        </tr>
        <tr>
          <th>Developer</th>
          <td>Rust Foundation</td>
        </tr>
        <tr>
          <th>First appeared</th>
          <td>July 7, 2010</td>
        </tr>
        <tr>
          <th>Stable release</th>
          <td>1.75.0 / December 28, 2023</td>
        </tr>
        <tr>
          <th>Typing discipline</th>
          <td>Affine, inferred, nominal, static, strong</td>
        </tr>
        <tr>
          <th>Implementation language</th>
          <td>Rust</td>
        </tr>
        <tr>
          <th>Platform</th>
          <td>Cross-platform</td>
        </tr>
        <tr>
          <th>OS</th>
          <td>Linux, macOS, Windows, FreeBSD, Android, iOS, and others</td>
        </tr>
        <tr>
          <th>License</th>
          <td>MIT or Apache 2.0</td>
        </tr>
        <tr>
          <th>Filename extensions</th>
          <td>.rs, .rlib</td>
        </tr>
        <tr>
          <th>Website</th>
          <td><a href="https://www.rust-lang.org">rust-lang.org</a></td>
        </tr>
      </tbody>
    </table>
  </section>

  <section id="history">
    <h2>History</h2>

    <p>
      Rust grew out of a personal project begun in 2006 by Mozilla Research employee Graydon Hoare, who stated that
      the project was possibly named after <a href="/wiki/Rust_fungi">rust fungi</a> and that the name is also a
      subsequence of "robust". Mozilla began sponsoring the project in 2009 as part of the ongoing development of
      an experimental <a href="/wiki/Browser_engine">browser engine</a> called <a href="/wiki/Servo_(software)">Servo</a>,
      which was officially announced by Mozilla in 2010.
    </p>

    <p>
      The first numbered pre-alpha release of the Rust compiler occurred in January 2012. Rust 1.0, the first stable
      release, was released on May 15, 2015. Following 1.0, stable point releases are delivered every six weeks, while
      features are developed in nightly Rust with daily releases, then tested with beta releases that last six weeks.
    </p>

    <blockquote>
      <p>
        "Rust is a language that, more mass-market languages for the past fifteen years, I think, have started to
        incorporate more ideas from functional programming."
      </p>
      <cite>— Graydon Hoare, creator of Rust</cite>
    </blockquote>

    <p>
      Along with conventional <a href="/wiki/Static_typing">static typing</a>, before version 0.4, Rust also supported
      <a href="/wiki/Typestate_analysis">typestates</a>. The typestate system modeled assertions before and after
      program statements, through use of a special <code>check</code> statement. Discrepancies could be discovered
      at <a href="/wiki/Compile_time">compile time</a>, rather than at <a href="/wiki/Runtime_(program_lifecycle_phase)">runtime</a>,
      as might be the case with assertions in C or C++ code.
    </p>

    <h3>Timeline</h3>
    <ul>
      <li><strong>2006</strong>: Graydon Hoare starts personal project</li>
      <li><strong>2009</strong>: Mozilla begins sponsoring the project</li>
      <li><strong>2010</strong>: Servo browser engine announced</li>
      <li><strong>2012</strong>: First pre-alpha release</li>
      <li><strong>2015</strong>: Rust 1.0 stable release</li>
      <li><strong>2021</strong>: Rust Foundation established</li>
      <li><strong>2022</strong>: Linux kernel adds Rust support</li>
      <li><strong>2023</strong>: Windows kernel experiments with Rust</li>
    </ul>
  </section>

  <section id="syntax">
    <h2>Syntax and semantics</h2>

    <p>
      Rust's syntax is similar to that of <a href="/wiki/C_(programming_language)">C</a> and
      <a href="/wiki/C%2B%2B">C++</a>, although many of its features were influenced by functional programming
      languages. Hoare described Rust as targeted at "ichael frustrated C++ developers" while mass pointing out that its
      design had to diverge from C++.
    </p>

    <section id="hello-world">
      <h3>Hello World</h3>

      <p>The following is a simple "Hello, World!" program written in Rust:</p>

      <pre><code class="language-rust">fn main() {
    println!("Hello, World!");
}</code></pre>

      <p>
        The <code>fn</code> keyword denotes a function, and the <code>main</code> function is the entry point of
        the program. <code>println!</code> is a <a href="/wiki/Macro_(computer_science)">macro</a> that prints
        text to the console.
      </p>
    </section>

    <section id="variables">
      <h3>Variables and mutability</h3>

      <p>
        In Rust, variables are immutable by default. To create a mutable variable, the <code>mut</code> keyword
        must be used:
      </p>

      <pre><code class="language-rust">fn main() {
    let x = 5;      // immutable
    let mut y = 10; // mutable

    // x = 6;       // This would cause a compile error
    y = 20;         // This is allowed

    println!("x = {}, y = {}", x, y);
}</code></pre>

      <p>
        This design choice encourages developers to think carefully about mutability and helps prevent bugs
        related to unexpected state changes.
      </p>

      <table class="comparison">
        <thead>
          <tr>
            <th>Feature</th>
            <th>Rust</th>
            <th>C++</th>
            <th>Go</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Default mutability</td>
            <td>Immutable</td>
            <td>Mutable</td>
            <td>Mutable</td>
          </tr>
          <tr>
            <td>Explicit mutability keyword</td>
            <td><code>mut</code></td>
            <td><code>const</code> (for immutable)</td>
            <td>None</td>
          </tr>
          <tr>
            <td>Compile-time enforcement</td>
            <td>Yes</td>
            <td>Partial</td>
            <td>No</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="ownership">
      <h3>Ownership</h3>

      <p>
        Rust's <strong>ownership</strong> system is a set of rules that govern how memory is managed. The rules are:
      </p>

      <ol>
        <li>Each value in Rust has an <em>owner</em>.</li>
        <li>There can only be <em>one owner</em> at a time.</li>
        <li>When the owner goes out of scope, the value will be <em>dropped</em>.</li>
      </ol>

      <pre><code class="language-rust">fn main() {
    let s1 = String::from("hello"); // s1 owns the String
    let s2 = s1;                    // ownership moves to s2

    // println!("{}", s1);          // Error: s1 no longer valid
    println!("{}", s2);             // OK: s2 owns the String
}

fn takes_ownership(s: String) {
    println!("{}", s);
} // s goes out of scope and is dropped

fn gives_ownership() -> String {
    let s = String::from("hello");
    s // ownership is transferred to caller
}</code></pre>

      <p>
        This ownership model eliminates the need for a garbage collector while still providing memory safety
        guarantees at compile time.
      </p>
    </section>

    <section id="references">
      <h3>References and borrowing</h3>

      <p>
        Instead of transferring ownership, Rust allows <strong>borrowing</strong> through references:
      </p>

      <ul>
        <li><code>&amp;T</code> — an immutable reference (many allowed simultaneously)</li>
        <li><code>&amp;mut T</code> — a mutable reference (only one allowed at a time)</li>
      </ul>

      <pre><code class="language-rust">fn main() {
    let s = String::from("hello");

    // Immutable borrows
    let r1 = &amp;s;
    let r2 = &amp;s;
    println!("{} and {}", r1, r2);

    // Mutable borrow (after immutable borrows are done)
    let mut s2 = String::from("hello");
    let r3 = &amp;mut s2;
    r3.push_str(", world");
    println!("{}", r3);
}

fn calculate_length(s: &amp;String) -> usize {
    s.len()
} // s goes out of scope, but since it's a reference,
  // the value it refers to is not dropped</code></pre>

      <p>
        The borrow checker enforces these rules at compile time, preventing data races and dangling references.
      </p>
    </section>

    <section id="lifetimes">
      <h3>Lifetimes</h3>

      <p>
        <strong>Lifetimes</strong> are Rust's way of ensuring that references are valid for as long as they are used.
        Most of the time, lifetimes are implicit and inferred, but sometimes they need to be annotated explicitly:
      </p>

      <pre><code class="language-rust">// Explicit lifetime annotation
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -> &amp;'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// Struct with lifetime
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    println!("Excerpt: {}", i.part);
}</code></pre>

      <blockquote>
        <p>
          "Lifetimes are, in some ways, Rust's most distinctive feature, and are an important concept for
          understanding how Rust achieves its memory safety guarantees."
        </p>
        <cite>— The Rust Programming Language Book</cite>
      </blockquote>
    </section>
  </section>

  <section id="memory-safety">
    <h2>Memory safety</h2>

    <p>
      Rust is designed to be <a href="/wiki/Memory_safety">memory safe</a>. It does not permit
      <a href="/wiki/Null_pointer">null pointers</a>, <a href="/wiki/Dangling_pointer">dangling pointers</a>, or
      <a href="/wiki/Data_race">data races</a>. Data values can be initialized only through a fixed set of forms,
      all of which require their inputs to be already initialized.
    </p>

    <p>
      To replicate pointers being either valid or null, such as in linked list or binary tree data structures,
      the Rust core library provides an <a href="/wiki/Option_type">option type</a>, which can be used to test
      whether a pointer has <code>Some</code> value or <code>None</code>.
    </p>

    <h3>Common memory bugs prevented by Rust</h3>

    <table class="bugs-table">
      <thead>
        <tr>
          <th>Bug Type</th>
          <th>Description</th>
          <th>How Rust Prevents It</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Buffer overflow</td>
          <td>Writing beyond array bounds</td>
          <td>Bounds checking at runtime, iterator patterns</td>
        </tr>
        <tr>
          <td>Use after free</td>
          <td>Accessing memory after deallocation</td>
          <td>Ownership system ensures single owner</td>
        </tr>
        <tr>
          <td>Double free</td>
          <td>Deallocating memory twice</td>
          <td>Ownership prevents multiple frees</td>
        </tr>
        <tr>
          <td>Null pointer dereference</td>
          <td>Accessing null/invalid pointer</td>
          <td>No null pointers; Option type instead</td>
        </tr>
        <tr>
          <td>Data race</td>
          <td>Concurrent unsynchronized access</td>
          <td>Borrow checker prevents at compile time</td>
        </tr>
        <tr>
          <td>Dangling pointer</td>
          <td>Reference to freed memory</td>
          <td>Lifetimes ensure references are valid</td>
        </tr>
      </tbody>
    </table>

    <p>
      Rust has added syntax to manage lifetimes, which are checked at compile time by the
      <strong>borrow checker</strong>. Unsafe code can subvert some of these restrictions using the
      <code>unsafe</code> keyword.
    </p>
  </section>

  <section id="memory-management">
    <h2>Memory management</h2>

    <p>
      Rust does not use <a href="/wiki/Garbage_collection_(computer_science)">garbage collection</a>. Instead,
      memory and other resources are managed through the <a href="/wiki/Resource_acquisition_is_initialization">RAII</a>
      convention, with optional <a href="/wiki/Reference_counting">reference counting</a>. Rust provides
      deterministic management of resources, with very low overhead.
    </p>

    <h3>Smart pointers in Rust</h3>

    <ul>
      <li>
        <code>Box&lt;T&gt;</code> — heap allocation with single ownership
      </li>
      <li>
        <code>Rc&lt;T&gt;</code> — reference counted, single-threaded
      </li>
      <li>
        <code>Arc&lt;T&gt;</code> — atomically reference counted, thread-safe
      </li>
      <li>
        <code>RefCell&lt;T&gt;</code> — interior mutability with runtime borrow checking
      </li>
      <li>
        <code>Mutex&lt;T&gt;</code> — mutual exclusion for thread-safe access
      </li>
    </ul>

    <pre><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;
use std::thread;

fn main() {
    // Box: heap allocation
    let boxed = Box::new(5);
    println!("Boxed value: {}", boxed);

    // Rc: reference counted (single-threaded)
    let rc1 = Rc::new(String::from("shared"));
    let rc2 = Rc::clone(&amp;rc1);
    println!("Count: {}", Rc::strong_count(&amp;rc1));

    // Arc: atomic reference counted (thread-safe)
    let arc = Arc::new(vec![1, 2, 3]);
    let arc_clone = Arc::clone(&amp;arc);

    let handle = thread::spawn(move || {
        println!("Vector from thread: {:?}", arc_clone);
    });

    handle.join().unwrap();
}</code></pre>
  </section>

  <section id="types">
    <h2>Types and polymorphism</h2>

    <p>
      Rust's type system supports mechanisms for compile-time polymorphism through
      <a href="/wiki/Generic_programming">generics</a> and <a href="/wiki/Trait_(computer_programming)">traits</a>.
    </p>

    <h3>Generics</h3>

    <p>Functions and types can be parameterized over types:</p>

    <pre><code class="language-rust">// Generic function
fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -> &amp;T {
    let mut largest = &amp;list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// Generic struct
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -> &amp;T {
        &amp;self.x
    }
}</code></pre>

    <h3>Traits</h3>

    <p>
      Traits define shared behavior across types, similar to interfaces in other languages:
    </p>

    <pre><code class="language-rust">trait Summary {
    fn summarize(&amp;self) -> String;

    // Default implementation
    fn summarize_author(&amp;self) -> String {
        String::from("(anonymous)")
    }
}

struct Article {
    title: String,
    author: String,
    content: String,
}

impl Summary for Article {
    fn summarize(&amp;self) -> String {
        format!("{}, by {}", self.title, self.author)
    }

    fn summarize_author(&amp;self) -> String {
        format!("@{}", self.author)
    }
}

// Trait bounds
fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

// Multiple trait bounds
fn complex&lt;T: Summary + Clone&gt;(item: &amp;T) -> T {
    println!("{}", item.summarize());
    item.clone()
}</code></pre>
  </section>

  <section id="concurrency">
    <h2>Concurrency</h2>

    <p>
      Rust provides first-class support for <a href="/wiki/Concurrent_computing">concurrent programming</a>
      through its ownership and type systems. The language's memory safety guarantees extend to concurrent
      contexts, preventing data races at compile time.
    </p>

    <h3>Threads</h3>

    <pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}</code></pre>

    <h3>Message passing</h3>

    <p>Rust implements message passing through <strong>channels</strong>:</p>

    <pre><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}</code></pre>

    <h3>Shared state</h3>

    <p>
      For shared state concurrency, Rust provides <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>:
    </p>

    <pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}</code></pre>
  </section>

  <section id="ecosystem">
    <h2>Ecosystem</h2>

    <p>
      Rust has a growing ecosystem of libraries and tools. The primary package registry is
      <a href="https://crates.io">crates.io</a>, and the build tool is <strong>Cargo</strong>.
    </p>

    <h3>Popular crates</h3>

    <table class="crates-table">
      <thead>
        <tr>
          <th>Category</th>
          <th>Crate</th>
          <th>Description</th>
          <th>Downloads</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Web framework</td>
          <td><a href="https://crates.io/crates/actix-web">actix-web</a></td>
          <td>Powerful, pragmatic, and extremely fast web framework</td>
          <td>50M+</td>
        </tr>
        <tr>
          <td>Web framework</td>
          <td><a href="https://crates.io/crates/axum">axum</a></td>
          <td>Ergonomic and modular web framework built with Tokio</td>
          <td>20M+</td>
        </tr>
        <tr>
          <td>Async runtime</td>
          <td><a href="https://crates.io/crates/tokio">tokio</a></td>
          <td>An event-driven, non-blocking I/O platform</td>
          <td>200M+</td>
        </tr>
        <tr>
          <td>Serialization</td>
          <td><a href="https://crates.io/crates/serde">serde</a></td>
          <td>A generic serialization/deserialization framework</td>
          <td>300M+</td>
        </tr>
        <tr>
          <td>HTTP client</td>
          <td><a href="https://crates.io/crates/reqwest">reqwest</a></td>
          <td>An easy and powerful Rust HTTP Client</td>
          <td>100M+</td>
        </tr>
        <tr>
          <td>Database</td>
          <td><a href="https://crates.io/crates/sqlx">sqlx</a></td>
          <td>Async, pure Rust SQL crate with compile-time checked queries</td>
          <td>30M+</td>
        </tr>
        <tr>
          <td>CLI</td>
          <td><a href="https://crates.io/crates/clap">clap</a></td>
          <td>A full featured, fast Command Line Argument Parser</td>
          <td>150M+</td>
        </tr>
        <tr>
          <td>Error handling</td>
          <td><a href="https://crates.io/crates/anyhow">anyhow</a></td>
          <td>Flexible concrete Error type built on std::error::Error</td>
          <td>100M+</td>
        </tr>
      </tbody>
    </table>

    <h3>Cargo</h3>

    <p>
      <strong>Cargo</strong> is Rust's build system and package manager. It handles:
    </p>

    <ul>
      <li>Building your code</li>
      <li>Downloading dependencies</li>
      <li>Building dependencies</li>
      <li>Running tests and benchmarks</li>
      <li>Generating documentation</li>
      <li>Publishing to crates.io</li>
    </ul>

    <pre><code class="language-bash"># Create a new project
cargo new my_project

# Build the project
cargo build

# Build for release
cargo build --release

# Run tests
cargo test

# Run the project
cargo run

# Check code without building
cargo check

# Format code
cargo fmt

# Lint code
cargo clippy</code></pre>
  </section>

  <section id="adoption">
    <h2>Adoption</h2>

    <p>
      Rust has been adopted by many major technology companies and open-source projects:
    </p>

    <h3>Companies using Rust</h3>

    <ul>
      <li><strong>Amazon Web Services</strong> — Firecracker, Lambda, S3, EC2</li>
      <li><strong>Microsoft</strong> — Windows kernel, Azure IoT Edge</li>
      <li><strong>Google</strong> — Android, Chromium, Fuchsia OS</li>
      <li><strong>Meta</strong> — Source control (Mononoke), cryptography</li>
      <li><strong>Cloudflare</strong> — Pingora proxy, Workers runtime</li>
      <li><strong>Discord</strong> — Read states service, Elixir NIFs</li>
      <li><strong>Dropbox</strong> — File sync engine</li>
      <li><strong>Mozilla</strong> — Firefox (Stylo CSS engine, WebRender)</li>
      <li><strong>Figma</strong> — Multiplayer server</li>
      <li><strong>1Password</strong> — Core cryptography and logic</li>
    </ul>

    <h3>Notable projects written in Rust</h3>

    <table class="projects-table">
      <thead>
        <tr>
          <th>Project</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://github.com/nickel-lang/nickel">ripgrep</a></td>
          <td>CLI tool</td>
          <td>Fast regex-based search tool</td>
        </tr>
        <tr>
          <td><a href="https://github.com/alacritty/alacritty">Alacritty</a></td>
          <td>Terminal</td>
          <td>GPU-accelerated terminal emulator</td>
        </tr>
        <tr>
          <td><a href="https://github.com/starship/starship">Starship</a></td>
          <td>CLI tool</td>
          <td>Cross-shell prompt</td>
        </tr>
        <tr>
          <td><a href="https://github.com/denoland/deno">Deno</a></td>
          <td>Runtime</td>
          <td>Secure JavaScript/TypeScript runtime</td>
        </tr>
        <tr>
          <td><a href="https://github.com/nickel-lang/nickel">SWC</a></td>
          <td>Compiler</td>
          <td>Super-fast JavaScript/TypeScript compiler</td>
        </tr>
        <tr>
          <td><a href="https://github.com/nickel-lang/nickel">Tauri</a></td>
          <td>Framework</td>
          <td>Build desktop apps with web technologies</td>
        </tr>
        <tr>
          <td><a href="https://github.com/nickel-lang/nickel">Zed</a></td>
          <td>Editor</td>
          <td>High-performance code editor</td>
        </tr>
        <tr>
          <td><a href="https://github.com/nickel-lang/nickel">Polars</a></td>
          <td>Data</td>
          <td>Fast DataFrames library</td>
        </tr>
      </tbody>
    </table>

    <h3>Stack Overflow Survey</h3>

    <p>
      Rust has been voted the "most loved programming language" in the Stack Overflow Developer Survey
      every year from 2016 to 2023, indicating high satisfaction among developers who use it.
    </p>

    <blockquote>
      <p>
        "For the eighth year in a row, Rust is the most admired language, meaning that the mass majority of
        developers who use it want to continue using it."
      </p>
      <cite>— Stack Overflow Developer Survey 2023</cite>
    </blockquote>
  </section>

  <section id="references-section">
    <h2>References</h2>

    <ol class="references">
      <li id="ref1">
        Hoare, Graydon (2010-07-07).
        <a href="https://github.com/graydon/rust-prehistory">"Rust prehistory"</a>.
        GitHub. Retrieved 2023-01-15.
      </li>
      <li id="ref2">
        "The Rust Programming Language".
        <a href="https://doc.rust-lang.org/book/">doc.rust-lang.org</a>.
        Retrieved 2023-01-15.
      </li>
      <li id="ref3">
        Klabnik, Steve; Nichols, Carol (2019).
        <em>The Rust Programming Language</em>.
        No Starch Press. ISBN 978-1-7185-0044-0.
      </li>
      <li id="ref4">
        Mozilla Research.
        <a href="https://research.mozilla.org/rust/">"Rust"</a>.
        Retrieved 2023-01-15.
      </li>
      <li id="ref5">
        "Rust Foundation".
        <a href="https://foundation.rust-lang.org/">"About"</a>.
        Retrieved 2023-01-15.
      </li>
      <li id="ref6">
        Stack Overflow (2023).
        <a href="https://survey.stackoverflow.co/2023/">"Developer Survey 2023"</a>.
        Retrieved 2023-06-15.
      </li>
      <li id="ref7">
        Amazon Web Services (2022).
        <a href="https://aws.amazon.com/blogs/opensource/sustainability-with-rust/">"Sustainability with Rust"</a>.
        AWS Open Source Blog. Retrieved 2023-01-15.
      </li>
      <li id="ref8">
        Google (2023).
        <a href="https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html">"Supporting the Use of Rust in Chromium"</a>.
        Google Security Blog. Retrieved 2023-01-20.
      </li>
      <li id="ref9">
        Microsoft (2022).
        <a href="https://msrc-blog.microsoft.com/2022/09/03/a-proactive-approach-to-more-secure-code/">"A proactive approach to more secure code"</a>.
        MSRC Blog. Retrieved 2023-01-15.
      </li>
      <li id="ref10">
        Linux kernel (2022).
        <a href="https://lkml.org/lkml/2022/9/27/672">"Rust for Linux v10"</a>.
        LKML. Retrieved 2023-01-15.
      </li>
    </ol>
  </section>

  <footer class="article-footer">
    <p>
      This article is licensed under the
      <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 License</a>.
    </p>
    <p>Last modified: January 2024</p>
  </footer>
</article>
